# Система типов и настройки

Написать эту заметку меня побудила статья [Как устроена система типов typescript](https://ru.hexlet.io/blog/posts/sistema-tipov-v-typescript)

Являясь неискушенным пользователем языка я обратил внимание на базовые случаи с которыми имел дело в разных проектах.
Вариант 1:

```ts
type TA = number | string
type TB = string

type E1 = TA extends TB ? true : false // false
type E2 = TB extends TA ? true : false // true
```

Если мы примем семантику, что у нас есть типы и подтипы и применим принцип Барбары Лисков, то справа от extends у нас будет тип для которого выражение слева подтип.
И тогда, в любое место, где использован тип можно безопасно подставлять его подтип. 
Так как в данном случае мы работаем с примитивными типами нас не должно смущать, что подтип является более узким, чем тот, который он "расширяет".
Принцип продолжает работать и работа программ нарушена не будет.

Вариант 2:
```ts
type TC = (a: number | string) => void
type TD = (a: string) => void

type E3 = TC extends TD ? true : false // true
type E4 = TD extends TC ? true : false // true

let c: TC = a => undefined
let d: TD = a => {
  if (typeof a !== 'string') {
    throw 'error a in d'
  }
}

c = d
d = c
```

Вроде по смыслу ничего не поменялось, но ts перестал работать как ожидаем. Здесь у нас работает явно противоречащие принципу небезопасное присваивание

Вариант 3:
```ts
interface IA {
  setValue(a: number | string): void
}

class CB implements IA {
  setValue(a: string) {
    if (typeof a !== 'string') {
      throw 'error a in CB'
    }
  }
}

const oIA: IA = new CB
oIA.setValue(100)
```
Опять похожая ситуация. TS упорно не замечает какой такой принцип подстановки Барбары Лисков должен работать?

Частично ответ находится в настройке самого ts. За такие финты ушами отвечает `compilerOptions->strict` установленный в `true`
А так же может быть использована отдельная опция `strictFunctionTypes`. 

Подключение строгих проверок позволяет отлавливать ошибки типа в Вариант 2. Мы получим, что-то типа:
```
TS2322: Type TD is not assignable to type TC
  Types of parameters a and a are incompatible.
    Type string | number is not assignable to type string
      Type number is not assignable to type string
```

Но Вариант 3 исправить не получится. Ответ разработчиков ts звучит примерно так: 
> Во время разработки этой функции мы обнаружили большое количество изначально небезопасных иерархий классов, включая некоторые из них в DOM. В связи с этим настройка применяется только к функциям, написанным в синтаксисе функций, а не в синтаксисе методов

Поэтому при реализации интерфейсов, работе с объектами корректность соблюдения принципа подстановки Барбары Лисков ложится на плечи разработчиков


